package gen

import (
	"bytes"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"unicode"

	"github.com/segmentio/go-snakecase"
)

type FunctionInfo struct {
	Name        string
	Description string
	Params      []ParamInfo
	ReturnType  string
	ParamsDesc  map[string]string
}

type ParamInfo struct {
	Name        string
	Type        string
	Description string
}

type TemplateData struct {
	Package   string
	Functions []FunctionInfo
}

func GenTool(f string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, f, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	var funcInfos []FunctionInfo

	ast.Inspect(node, func(n ast.Node) bool {
		switch x := n.(type) {
		case *ast.FuncDecl:
			if strings.HasPrefix(x.Name.Name, "Tool") {
				funcInfo := FunctionInfo{
					Name:       strings.TrimPrefix(x.Name.Name, "Tool"),
					ParamsDesc: map[string]string{},
				}

				// 提取函数描述
				if x.Doc != nil {
					for _, comment := range x.Doc.List {
						commentText := strings.TrimSpace(strings.TrimPrefix(comment.Text, "//"))
						commentText = strings.TrimLeftFunc(commentText, func(r rune) bool {
							return unicode.IsSpace(r)
						})
						if commentText != "" {
							if strings.HasPrefix(commentText, "@") {
								// 参数描述
								spaceIndex := strings.Index(commentText, " ")
								if spaceIndex > 0 {
									funcInfo.ParamsDesc[commentText[1:spaceIndex]] = commentText[spaceIndex:]
								}
							} else {
								if strings.HasPrefix(commentText, x.Name.Name) {
									commentText = strings.TrimPrefix(commentText, x.Name.Name)
								}
								funcInfo.Description += commentText
							}

						}
						//prefix := x.Name.Name + " description="
						//if strings.HasPrefix(commentText, prefix) {
						//	funcInfo.Description = strings.TrimPrefix(commentText, prefix)
						//	break
						//}
					}
				}

				// 处理参数
				for _, field := range x.Type.Params.List {
					paramType := getTypeName(field.Type)
					for _, name := range field.Names {
						paramDesc := extractParamComment(funcInfo, name.Name)
						funcInfo.Params = append(funcInfo.Params, ParamInfo{
							Name:        name.Name,
							Type:        paramType,
							Description: paramDesc,
						})
					}
				}

				funcInfos = append(funcInfos, funcInfo)
			}
		}
		return true
	})

	if len(funcInfos) == 0 {
		return nil
	}

	data := TemplateData{
		Package:   node.Name.Name,
		Functions: funcInfos,
	}

	buff, err := generateCode(data)
	if err != nil {
		return err
	}

	dir := filepath.Dir(f)
	filename := filepath.Base(f)
	ext := filepath.Ext(filename)
	filename = filename[:len(filename)-len(ext)]
	outputFilename := filepath.Join(dir, filename+"_gen.go")
	return os.WriteFile(outputFilename, buff, 0600)
}

const toolTemplate = `// Code generated by toolgen; DO NOT EDIT.
package {{.Package}}

import (
	mcp_golang "github.com/metoro-io/mcp-golang"
	gen "github.com/chslink/mcp-tools/gen"
)


{{range .Functions}}
type {{.Name}}Arguments struct {
	{{- range .Params}}
	{{.Name | Title}} {{.Type}} ` + "`json:\"{{.Name | ToSnake}}\" jsonschema:\"description={{.Description}}\"`" + `
	{{- end}}
}

var {{.Name | ToLower}}Tool = gen.Tool{
	Name:        "{{.Name | ToSnake}}",
	Description: "{{.Description}}",
	Func: func(args {{.Name}}Arguments) (*mcp_golang.ToolResponse, error) {
		resp, err := Tool{{.Name}}({{range $i, $p := .Params}}{{if $i}}, {{end}}args.{{$p.Name | Title}}{{end}})
		return gen.ConvertMcpResp(resp, err)
	},
}
{{end}}

func init(){
{{range .Functions}}
	gen.RegisterTool({{.Name | ToLower}}Tool )
{{end}}
}
`

var genToolTemplate = template.Must(template.New("tool").Funcs(template.FuncMap{
	"Title":   strings.Title,
	"ToLower": strings.ToLower,
	"ToSnake": snakecase.Snakecase,
}).Parse(toolTemplate))

func generateCode(data TemplateData) ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	err := genToolTemplate.Execute(buf, data)
	return buf.Bytes(), err
}

func getTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return getTypeName(t.X) + "." + t.Sel.Name
	case *ast.StarExpr:
		return "*" + getTypeName(t.X)
	case *ast.ArrayType:
		return "[]" + getTypeName(t.Elt)
	default:
		return "interface{}"
	}
}

func extractParamComment(funcInfo FunctionInfo, name string) string {
	if funcInfo.ParamsDesc != nil {
		return funcInfo.ParamsDesc[name]
	}
	return ""
}
